/* ==========================================
 * jORLib : Java Operations Research Library
 * ==========================================
 *
 * Project Info:  http://www.coin-or.org/projects/jORLib.xml
 * Project Creator:  Joris Kinable (https://github.com/jkinable)
 *
 * (C) Copyright 2015-2016, by Joris Kinable and Contributors.
 *
 * This program and the accompanying materials are licensed under LGPLv2.1
 * as published by the Free Software Foundation.
 */
package org.jorlib.frameworks.columngeneration.io;

import org.jorlib.frameworks.columngeneration.branchandprice.AbstractBranchAndPrice;
import org.jorlib.frameworks.columngeneration.branchandprice.eventhandling.*;
import org.jorlib.frameworks.columngeneration.colgenmain.AbstractColumn;
import org.jorlib.frameworks.columngeneration.model.ModelInterface;
import org.jorlib.frameworks.columngeneration.pricing.AbstractPricingProblem;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.NumberFormat;

/**
 * Simple class which logs events from the Branch-and-Price class
 *
 * @author Joris Kinable
 * @version 5-5-2015
 */
public class SimpleBAPLogger<T extends ModelInterface, U extends AbstractColumn<T, V>, V extends AbstractPricingProblem<T, U>>
    implements BAPListener<T,U>
{
    protected BufferedWriter writer;
    protected NumberFormat formatter;

    /** Branch-and-Price node ID of node currently being solved **/
    protected int bapNodeID;
    /** Parent node ID, -1 if root node **/
    protected int parentNodeID;
    /** Best integer solution **/
    protected double objectiveIncumbentSolution;
    /** Bound on the BAP node **/
    protected double nodeBound;
    /**
     * What to do with the node, i.e prune (based on obj), Infeasible, Integer, Fractional, or
     * Inconclusive if the nodeStatus could not be determined (e.g. due to time limit)
     **/
    protected NodeResultStatus nodeStatus;
    /** Number of nodes currently in the queue **/
    protected int nodesInQueue;

    // ColGen stats
    /** Number of column generation iterations **/
    protected int cgIterations;

    // Master problem
    /** Counts how much time is spent on solving master problems **/
    protected long timeSolvingMaster;
    /** Objective value of bap node **/
    protected double nodeValue;

    // Pricing Problem
    /** Counts how much time is spend on solving pricing problems **/
    protected long timeSolvingPricing;
    /** Total number of columns generated by the pricing problems **/
    protected int nrGeneratedColumns;

    /**
     * Create a new logger which writes its output the the file specified
     * 
     * @param branchAndPrice Branch-and-Price instance for which this logger is created.
     * @param outputFile file to redirect the output to.
     */
    public SimpleBAPLogger(AbstractBranchAndPrice<T, U, V> branchAndPrice, File outputFile)
    {
        try {
            writer = new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            e.printStackTrace();
        }
        formatter = new DecimalFormat("#0.00");
        branchAndPrice.addBranchAndPriceEventListener(this);
    }

    /**
     * Write a single line of text to the output file
     * 
     * @param line line of text to be written
     */
    protected void writeLine(String line)
    {
        try {
            writer.write(line);
            writer.newLine();
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Reset the values
     */
    protected void reset()
    {
        bapNodeID = -1;
        parentNodeID = -1;
        objectiveIncumbentSolution = -1;
        nodeBound = -1;
        cgIterations = 0;
        timeSolvingMaster = 0;
        nodeValue = -1;
        timeSolvingPricing = 0;
        nrGeneratedColumns = 0;
        nodesInQueue = -1;
    }

    /**
     * Construct a single line in the log file, and write it to the output file
     */
    protected void constructAndWriteLine()
    {
        this.writeLine(
            String.valueOf(bapNodeID) + "\t" + parentNodeID + "\t" + objectiveIncumbentSolution
                + "\t" + nodeBound + "\t" + formatter.format(nodeValue) + "\t" + cgIterations + "\t"
                + timeSolvingMaster + "\t" + timeSolvingPricing + "\t" + nrGeneratedColumns + "\t"
                + nodeStatus + "\t" + nodesInQueue);
    }

    @Override
    public void startBAP(StartEvent startEvent)
    {
        this.writeLine(
            "BAPNodeID \t parentNodeID \t objectiveIncumbentSolution \t nodeBound \t nodeValue \t cgIterations \t t_master \t t_pricing \t nrGenColumns \t solutionStatus \t nodesInQueue");
    }

    @Override
    public void finishBAP(FinishEvent finishEvent)
    {
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void pruneNode(PruneNodeEvent<T,U> pruneNodeEvent)
    {
        this.nodeStatus = NodeResultStatus.PRUNED;
        this.nodeBound = pruneNodeEvent.nodeBound;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsInfeasible(NodeIsInfeasibleEvent<T,U> nodeIsInfeasibleEvent)
    {
        this.nodeStatus = NodeResultStatus.INFEASIBLE;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsInteger(NodeIsIntegerEvent<T,U> nodeIsIntegerEvent)
    {
        this.nodeStatus = NodeResultStatus.INTEGER;
        this.constructAndWriteLine();
    }

    @Override
    public void nodeIsFractional(NodeIsFractionalEvent<T,U> nodeIsFractionalEvent)
    {
        this.nodeStatus = NodeResultStatus.FRACTIONAL;
        this.constructAndWriteLine();
    }

    @Override
    public void processNextNode(ProcessingNextNodeEvent<T,U> processingNextNodeEvent)
    {
        this.reset();
        this.bapNodeID = processingNextNodeEvent.node.nodeID;
        this.parentNodeID = processingNextNodeEvent.node.getParentID();
        this.objectiveIncumbentSolution = processingNextNodeEvent.objectiveIncumbentSolution;
        this.nodesInQueue = processingNextNodeEvent.nodesInQueue;
    }

    @Override
    public void finishedColumnGenerationForNode(FinishProcessingNodeEvent<T,U> finishProcessingNodeEvent)
    {
        this.nodeBound = finishProcessingNodeEvent.nodeBound;
        this.nodeValue = finishProcessingNodeEvent.nodeValue;
        this.cgIterations = finishProcessingNodeEvent.numberOfCGIterations;
        this.timeSolvingMaster = finishProcessingNodeEvent.masterSolveTime;
        this.timeSolvingPricing = finishProcessingNodeEvent.pricingSolveTime;
        this.nrGeneratedColumns = finishProcessingNodeEvent.nrGeneratedColumns;
    }

    @Override
    public void timeLimitExceeded(TimeLimitExceededEvent timeLimitExceededEvent)
    {
        this.nodeStatus = NodeResultStatus.INCONCLUSIVE;
        this.constructAndWriteLine();
    }

    @Override
    public void branchCreated(BranchEvent<T,U> branchEvent)
    {
        // Ignore this event, not needed by the logger.
    }

    protected enum NodeResultStatus
    {
        PRUNED,
        INFEASIBLE,
        FRACTIONAL,
        INTEGER,
        INCONCLUSIVE
    }
}
